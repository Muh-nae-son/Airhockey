#include <Wire.h>
#include <SparkFun_BNO080_Arduino_Library.h>

BNO080 imu;

// Stored inverse "home" quaternion for reset
float q0_ref = 1, q1_ref = 0, q2_ref = 0, q3_ref = 0;

// Quaternion multiplication
void quatMultiply(float& w, float& x, float& y, float& z,
                  float w2, float x2, float y2, float z2) {

  float nw = w*w2 - x*x2 - y*y2 - z*z2;
  float nx = w*x2 + x*w2 + y*z2 - z*y2;
  float ny = w*y2 - x*z2 + y*w2 + z*x2;
  float nz = w*z2 + x*y2 - y*x2 + z*w2;

  w = nw; x = nx; y = ny; z = nz;
}

// Convert quaternion â†’ yaw, pitch, roll (degrees)
void quatToEuler(float w, float x, float y, float z, 
                 float& yaw, float& pitch, float& roll) {

  yaw = atan2f(2.0f * (w*z + x*y),
               1.0f - 2.0f * (y*y + z*z)) * 57.2958f;

  float sinp = 2.0f * (w*y - z*x);
  pitch = (fabs(sinp) >= 1) ? copysignf(90.0f, sinp)
                            : asinf(sinp) * 57.2958f;

  roll = atan2f(2.0f * (w*x + y*z),
                1.0f - 2.0f * (x*x + y*y)) * 57.2958f;
}

void setup() {
  Serial.begin(115200);
  delay(500);

  Wire.begin(4, 5);   // ESP8266: SDA=4, SCL=5

  if (!imu.begin()) {
    Serial.println("IMU not detected!");
    while (1);
  }

  // Use Game Rotation Vector = stable, drift-free, NO magnetometer
  imu.enableGameRotationVector(100);

  Serial.println("BNO086 ready.");
  Serial.println("Type 'r' and press ENTER to reset orientation.");
}

void loop() {

  // --- Handle Serial commands ---
  if (Serial.available()) {
    char cmd = Serial.read();
    if (cmd == 'r' || cmd == 'R') {

      Serial.println("Orientation reset");

      // Read current quaternion from IMU
      float qw = imu.getQuatReal();
      float qx = imu.getQuatI();
      float qy = imu.getQuatJ();
      float qz = imu.getQuatK();

      // store inverse of quaternion as calibration reference
      q0_ref =  qw;
      q1_ref = -qx;
      q2_ref = -qy;
      q3_ref = -qz;
    }
  }

  // --- Read IMU data ---
  if (imu.dataAvailable()) {

    float w = imu.getQuatReal();
    float x = imu.getQuatI();
    float y = imu.getQuatJ();
    float z = imu.getQuatK();

    // Apply reset quaternion (inverse of starting orientation)
    quatMultiply(w, x, y, z, q0_ref, q1_ref, q2_ref, q3_ref);

    float yaw, pitch, roll;
    quatToEuler(w, x, y, z, yaw, pitch, roll);

    Serial.print("Yaw: ");
    Serial.print(yaw);
    Serial.print("  Pitch: ");
    Serial.print(pitch);
    Serial.print("  Roll: ");
    Serial.println(roll);
  }

  delay(5);
}
